#!/usr/bin/env python3
}


def normalize_availability(val: str) -> str:
if not val:
return DEFAULT_AVAILABILITY
key = re.sub(r"\s+", " ", val.strip().lower())
return _ALLOWED_AVAIL.get(key, DEFAULT_AVAILABILITY)




def fetch_xml(url: str) -> ET.ElementTree:
req = Request(url, headers={"User-Agent": "LIA-Builder/1.0"})
with urlopen(req, timeout=60) as resp:
data = resp.read()
return ET.ElementTree(ET.fromstring(data))




def extract_items(tree: ET.ElementTree):
root = tree.getroot()
items = []
# Obsługa typowych struktur RSS (rss/channel/item) z namespace g:
# Fallback: wszystkie elementy o nazwie 'item'
for it in root.findall(".//item"):
gid = it.findtext("g:id", default=None, namespaces=NS) or it.findtext("id")
if not gid:
continue
availability = it.findtext("g:availability", default=None, namespaces=NS) or it.findtext("availability")
price = it.findtext("g:price", default=None, namespaces=NS) or it.findtext("price")
items.append({
"id": gid.strip(),
"availability": normalize_availability(availability) if availability else DEFAULT_AVAILABILITY,
"price": price.strip() if price else None,
})
if not items:
raise RuntimeError("No <item> entries with g:id found in source feed")
return items




def ensure_dist():
outdir = pathlib.Path("dist")
outdir.mkdir(parents=True, exist_ok=True)
return outdir




def write_xml(items, outpath: pathlib.Path):
rss = ET.Element("rss", attrib={"version": "2.0"})
rss.set("xmlns:g", NS["g"])
channel = ET.SubElement(rss, "channel")
ET.SubElement(channel, "title").text = "Local Inventory Feed"
ET.SubElement(channel, "link").text = "https://example.invalid/"
ET.SubElement(channel, "description").text = "Generated by LIA Builder"


for it in items:
item = ET.SubElement(channel, "item")
ET.SubElement(item, ET.QName(NS["g"], "id")).text = it["id"]
ET.SubElement(item, ET.QName(NS["g"], "store_code")).text = STORE_CODE
ET.SubElement(item, ET.QName(NS["g"], "availability")).text = it["availability"]
if it.get("price"):
ET.SubElement(item, ET.QName(NS["g"], "price")).text = it["price"]


tree = ET.ElementTree(rss)
# Pisz z deklaracją XML i UTF-8
tree.write(outpath, encoding="utf-8", xml_declaration=True)




def write_tsv(items, outpath: pathlib.Path):
with outpath.open("w", newline="", encoding="utf-8") as f:
w = csv.writer(f, delimiter="\t")
w.writerow(["id", "store_code", "availability", "price"]) # quantity opcjonalnie – pomijamy
for it in items:
w.writerow([it["id"], STORE_CODE, it["availability"], it.get("price") or ""])




def main():
tree = fetch_xml(SOURCE_FEED_URL)
items = extract_items(tree)
outdir = ensure_dist()
ts = datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")


xml_out = outdir / f"{OUT_BASENAME}.xml"
tsv_out = outdir / f"{OUT_BASENAME}.tsv"


write_xml(items, xml_out)
write_tsv(items, tsv_out)


print(f"Wrote: {xml_out} and {tsv_out} ({len(items)} rows)")


if __name__ == "__main__":
main()
